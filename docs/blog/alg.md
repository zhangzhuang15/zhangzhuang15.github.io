---
title: "Interesting ALG"
page: true 
aside: true
---

# Interesting ALG
收集有趣的算法，附上代码实现

## 异或运算和减法
如果有一个非负整数N, N=2<sup>n</sup> - 1, n 是非负整数，还有一个非负整数m (0 <= m <= N), 下面的运算是等效的：
`N - m == N^m`

右边的异或运算要比减法快，因此作为减法替代，加快运算的一种手段。原理在于，如果按照2进制的角度看，N的0到n-1位都是1，其余都是0，而m的0到n-1位有0也有1，其余都是0。二者异或运算的结果，刚好就是把m的0到n-1位，原本是1的变成0，原本是0的变成1，这样的结果加上m，刚好就是N。

但一定要注意，这种技巧成立的前提是 N + 1 必须是 2 的整数次幂。


## 寻找64位整数最高位1的位置
现在有一个整数N，它是64位整数，把它写成二进制的形式，从高位往低位看，你能找到第一个是1的数位么？

De Bruijn 算法：
```c 
static const char kDebruijn[64] = {
    0,  47, 1,  56, 48, 27, 2,  60, 57, 49, 41, 37, 28, 16, 3,  61, 54, 58, 35, 52, 50, 42,
    21, 44, 38, 32, 29, 23, 17, 11, 4,  62, 46, 55, 26, 59, 40, 36, 15, 53, 34, 51, 20, 43,
    31, 22, 10, 45, 25, 39, 14, 33, 19, 30, 9,  24, 13, 18, 8,  12, 7,  6,  5,  63,
};

x |= x >> 1;
x |= x >> 2;
x |= x >> 4;
x |= x >> 8;
x |= x >> 16;
x |= x >> 32;
return kDebruijn[(x * 0x03f79d71b4cb0a89) >> 58];
```
假设x是0x20, 那么上述计算的结果就是5（0-based）。

[从哪里发现的](https://github.com/jart/bestline/blob/master/bestline.c)


如果改成研究32位整数，算法改为：
```c 
static const int debruijn32[32] = {
  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};

x |= x >> 1;
x |= x >> 2;
x |= x >> 4;
x |= x >> 8;
x |= x >> 16;

return kDebruijn[(x * 0x077CB531U) >> 27];
```

如果是研究最低位是1，上述64位和32位的算法里，只需要把关于x的计算改为下面的方式即可：
```c
x = x & -x;
```

这个运算的巧妙之处在于，-x是补码形式，它保留了x最低位是1的那一位，比这个位低的，都是0，比这个位高的，都变成了x原本数位的相反数（1的变成0，0的变成1），二者一旦采取与运算，结果就是最位的1被保留，其余数位都是0。

这和前边介绍的x运算不一样:

```c 
x |= x >> 1;
x |= x >> 2;
x |= x >> 4;
x |= x >> 8;
x |= x >> 16;
```
运算的第一步做的事情很简单，从0位开始到31位，向右叠加，意思就是 a0 = a0 + a1, a1 = a1 + a2...a30 = a30 + a31.经过计算后，相邻数位尽最大可能都是1.

运算的第二部做的事情同理，从0位开始到31位，每2位一组，向右叠加，意思就是 a0 = a0+a2, a1 = a1+a3...经过计算后，每4位尽最大可能都是1.

后边的运算以此类推，当每16位一组，向右叠加之后，x最高位是1的数位，比它高的都是0，比它低的都是1。如 0b00010101, 变成 0b00011111。


